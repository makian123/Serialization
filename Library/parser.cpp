#include "parser.h"

#include <iostream>
#include <filesystem>
#include <string>

namespace fs = std::filesystem;

static std::string className;

std::ostream &operator<<(std::ostream &stream, const CXString &str){
	stream << clang_getCString(str);
	clang_disposeString(str);
	return stream;
}

std::string CXStringToString(const CXString &str) {
	std::string ret = std::string(clang_getCString(str));
	clang_disposeString(str);

	return ret;
}

Parser::Parser(const std::string &headerLocation) {
	headerPath = fs::path(headerLocation);
	generatedDirPath = fs::path(headerLocation + "generated/");
}

void Parser::Begin() {
	generatedSerializerHeader = std::ofstream(generatedDirPath.string() + "serializeSpecializations.h");
	generatedSerializerSource = std::ofstream(generatedDirPath.string() + "serializeSpecializations.cpp");

	generatedDeserializerHeader = std::ofstream(generatedDirPath.string() + "deserializeSpecializations.h");
	generatedDeserializerSource = std::ofstream(generatedDirPath.string() + "deserializeSpecializations.cpp");

	generatedSerializerHeader << 
		"//Do not touch, this is autogenerated\n#pragma once\n" <<
		"#include <string>\n\n";

	generatedSerializerSource <<
		"//Do not touch, this is autogenerated\n" << 
		"#include \"" << fs::relative(headerPath, generatedDirPath).string() << "/serialize.h\"\n\n";

	generatedDeserializerHeader <<
		"//Do not touch, this is autogenerated\n#pragma once\n" <<
		"#include <string>\n\n";

	generatedDeserializerSource <<
		"//Do not touch, this is autogenerated\n" <<
		"#include \"" << fs::relative(headerPath, generatedDirPath).string() << "/serialize.h\"\n\n";

	filePaths.clear();
}
void Parser::SerializeFile(const std::string &path) {
	filePaths.push_back(path);
}
void Parser::End() {
	if (!generatedSerializerHeader.is_open() || !generatedSerializerSource.is_open()) return;
	if (!generatedDeserializerHeader.is_open() || !generatedDeserializerSource.is_open()) return;

	for (const std::string &path : filePaths) {
		std::string relativeString = fs::relative(fs::path(path), generatedDirPath).string();
		generatedSerializerSource << "#include \"" << relativeString << "\"\n";
		generatedDeserializerSource << "#include \"" << relativeString << "\"\n";
	}
	generatedSerializerSource << "\n";
	generatedDeserializerSource << "\n";

	for (const std::string &path : filePaths) {
		CXIndex index = clang_createIndex(0, 0);
		CXTranslationUnit unit = clang_parseTranslationUnit(
			index,
			path.c_str(),
			nullptr, 0,
			nullptr, 0,
			CXTranslationUnit_None
		);

		if (!unit) {
			std::cout << "Error parsing translation unit" << std::endl;
			exit(1);
		}

		CXCursor cursor = clang_getTranslationUnitCursor(unit);
		clang_visitChildren(
			cursor,
			&Parser::VisitorHeader,
			this
		);
		clang_visitChildren(
			cursor,
			&Parser::VisitorSource,
			this
		);

		clang_disposeTranslationUnit(unit);
		clang_disposeIndex(index);
	}

	generatedSerializerHeader.flush();
	generatedSerializerSource.flush();

	generatedSerializerHeader.close();
	generatedSerializerSource.close();

	generatedDeserializerHeader.flush();
	generatedDeserializerSource.flush();

	generatedDeserializerHeader.close();
	generatedDeserializerSource.close();
}

CXChildVisitResult Parser::ParseHeader(CXCursor c, CXCursor parent) {
	CXType type = clang_getCursorType(c);
	CXCursorKind cursorKind = clang_getCursorKind(c);

	if (clang_Location_isFromMainFile(clang_getCursorLocation(c)) == 0) {
		return CXChildVisit_Continue;
	}

	if (cursorKind == CXCursor_ClassDecl || cursorKind == CXCursor_StructDecl) {
		std::string className = CXStringToString(clang_getCursorSpelling(c));

		if (!generatedSerializerHeader.is_open() || !generatedDeserializerHeader.is_open())
			return CXChildVisit_Break;

		generatedSerializerHeader << ((cursorKind == CXCursor_ClassDecl) ? "class" : "struct") << " " << className << ";\n";
		generatedSerializerHeader << "template<>\n" <<
			"std::string Serialize<" << className << ">(" << className << " obj);\n\n";

		generatedDeserializerHeader << ((cursorKind == CXCursor_ClassDecl) ? "class" : "struct") << " " << className << ";\n";
		generatedDeserializerHeader << "template<>\n" <<
			className << " Deserialize<" << className << ">(const std::string &in);\n\n";
	}

	return CXChildVisit_Recurse;
}

CXChildVisitResult Parser::ParseClass(CXCursor c, CXCursor parent) {
	CXType type = clang_getCursorType(c);
	CXCursorKind cursorKind = clang_getCursorKind(c);
	CXSourceLocation location = clang_getCursorLocation(c);

	if (clang_Location_isFromMainFile(location) == 0) {
		return CXChildVisit_Continue;
	}

	if (cursorKind == CXCursor_ClassDecl || cursorKind == CXCursor_StructDecl) {
		className = CXStringToString(clang_getCursorSpelling(c));


		if (!generatedSerializerSource.is_open())
			return CXChildVisit_Break;

		generatedSerializerSource << "template<>\n" <<
			"std::string Serialize<" << className << ">(" << className << " obj){\n";
		generatedSerializerSource << "\tstd::string ret;\n\n";

		generatedDeserializerSource << "template<>\n" <<
			className << " Deserialize<" << className << ">(const std::string &in){\n";
		generatedDeserializerSource << "\t" << className << " ret;\n" << 
			"\tsize_t offset = sizeof(size_t), temp = 0; \n\n";

		clang_visitChildren(
			c,
			&Parser::VisitorFields,
			this
		);

		generatedSerializerSource << "\n\tret.insert(0, sizeof(size_t), '\\0');\n" <<
			"\t*(size_t*)ret.data() = ret.size() - sizeof(size_t);\n\n" <<
			"\treturn ret;\n}\n\n";

		generatedDeserializerSource << "\treturn ret;\n}\n\n";
	}

	return CXChildVisit_Recurse;
}

CXChildVisitResult Parser::ParseFields(CXCursor c, CXCursor parent) {
	CXType type = clang_getCursorType(c);
	CXCursorKind cursorKind = clang_getCursorKind(c);

	if (cursorKind == CXCursor_FieldDecl) {
		std::string fieldName = CXStringToString(clang_getCursorSpelling(c));
		std::string typeName = CXStringToString(clang_getTypeSpelling(type));

		if (!generatedSerializerSource.is_open())
			return CXChildVisit_Break;

		generatedSerializerSource << "\tret += Serialize<" << typeName << ">(obj." << fieldName << ");\n";

		//TODO;
		generatedDeserializerSource <<
			"\tret." << fieldName << " = Deserialize<" << typeName << ">(in.substr(offset));\n" <<
			"\tmemcpy(&temp, (in.data() + offset), sizeof(size_t));\n" <<
			"\toffset += temp + sizeof(size_t);\n\n";
	}
	else {
		return CXChildVisit_Continue;
	}

	return CXChildVisit_Continue;
}